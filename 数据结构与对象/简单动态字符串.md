# 简单动态字符串
## SDS的定义
结构体如下：
```
struct sdshdr{
 int len;   //记录buf数组中已使用字节的数量，SDS中字符串的长度
 int free;  //记录buf数组中未使用字节的数量
 char buf[];//字节数组用于保存字符串
}
```
以下为示例：
![image](https://user-images.githubusercontent.com/46806208/152981587-c87b0576-3760-4853-ac2f-7fe946e11f22.png)
>free属性值为0，表示这个SDS没有分配任何未使用的空间。len的属性值为5，表示这个SDS保存了一个5字节的字符串。buf属性是一个char类型的数组，末尾保存了空字符` '\0' `
SDS：Simple Dynamic String 简单动态字符串

## SDS与C字符串的区别
###### 常数复杂度获取字符串长度
C语言使用长度为N+1的数组存放长度为N的字符串，因为最后一个位置要保存` '\0' `,不记录本身的长度信息，所以它获取字符串的长度复杂度为O(N)。但是Redis的SDS在len属性中记录了SDS的长度
所以获取一个字符串的长度的复杂度为O(1)。
###### 杜绝缓冲区溢出
SDS的空间分配策略杜绝了发生缓冲区溢出的可能性；当SDS API需要对SDS进行修改时，API会先检查SDS空间是否满足修改所需的需求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以SDS不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。简单来说，空间不满足，自动扩容。
###### 减少内存重分配次数
因为C字符串并不记录自身的长度，所以每次增加或者缩短一个字符串都会对内存进行重新分配。SDS为了避免C字符串的缺陷，使用free的未分配的空间来实现空间预分配和惰性空间释放策略。  
- 1.空间预分配
>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用的空间。通过这种预分配的策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降为最多N次。  

分配未使用的空间策略如下
>如果对SDS操作后，SDS的长度(len的值）小于1M,那么程序分配和len同样大小的未使用空间。  
如果对SDS操作后，SDS的长度(len的值）大于等于1M,那么程序会分配1M的未使用空间。
- 2.惰性空间释放
> 惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

-3.二进制安全
>C字符串中的字符必须符合某种编码(比如ASCII)，并且除了字符串的末尾之外，字符串里不能包含空的字符，否则最先被程序读入的空字符会被认为是字符串的末尾，这些限制使得C字符串只能保存文本数据，而不能保存
像图片、音频、视频、压缩文件这样的二进制数据。
